// Generated by gencpp from file camera_control_msgs/SetIntegerValueRequest.msg
// DO NOT EDIT!


#ifndef CAMERA_CONTROL_MSGS_MESSAGE_SETINTEGERVALUEREQUEST_H
#define CAMERA_CONTROL_MSGS_MESSAGE_SETINTEGERVALUEREQUEST_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace camera_control_msgs
{
template <class ContainerAllocator>
struct SetIntegerValueRequest_
{
  typedef SetIntegerValueRequest_<ContainerAllocator> Type;

  SetIntegerValueRequest_()
    : value(0)  {
    }
  SetIntegerValueRequest_(const ContainerAllocator& _alloc)
    : value(0)  {
  (void)_alloc;
    }



   typedef int32_t _value_type;
  _value_type value;





  typedef boost::shared_ptr< ::camera_control_msgs::SetIntegerValueRequest_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::camera_control_msgs::SetIntegerValueRequest_<ContainerAllocator> const> ConstPtr;

}; // struct SetIntegerValueRequest_

typedef ::camera_control_msgs::SetIntegerValueRequest_<std::allocator<void> > SetIntegerValueRequest;

typedef boost::shared_ptr< ::camera_control_msgs::SetIntegerValueRequest > SetIntegerValueRequestPtr;
typedef boost::shared_ptr< ::camera_control_msgs::SetIntegerValueRequest const> SetIntegerValueRequestConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::camera_control_msgs::SetIntegerValueRequest_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::camera_control_msgs::SetIntegerValueRequest_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::camera_control_msgs::SetIntegerValueRequest_<ContainerAllocator1> & lhs, const ::camera_control_msgs::SetIntegerValueRequest_<ContainerAllocator2> & rhs)
{
  return lhs.value == rhs.value;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::camera_control_msgs::SetIntegerValueRequest_<ContainerAllocator1> & lhs, const ::camera_control_msgs::SetIntegerValueRequest_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace camera_control_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::camera_control_msgs::SetIntegerValueRequest_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::camera_control_msgs::SetIntegerValueRequest_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::camera_control_msgs::SetIntegerValueRequest_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::camera_control_msgs::SetIntegerValueRequest_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::camera_control_msgs::SetIntegerValueRequest_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::camera_control_msgs::SetIntegerValueRequest_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::camera_control_msgs::SetIntegerValueRequest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "b3087778e93fcd34cc8d65bc54e850d1";
  }

  static const char* value(const ::camera_control_msgs::SetIntegerValueRequest_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xb3087778e93fcd34ULL;
  static const uint64_t static_value2 = 0xcc8d65bc54e850d1ULL;
};

template<class ContainerAllocator>
struct DataType< ::camera_control_msgs::SetIntegerValueRequest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "camera_control_msgs/SetIntegerValueRequest";
  }

  static const char* value(const ::camera_control_msgs::SetIntegerValueRequest_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::camera_control_msgs::SetIntegerValueRequest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# Used by :\n"
"# - set_black_level ROS service. (value = new targeted black level).\n"
"# - set_acquisition_frame_count ROS service (value = new targeted frame count).\n"
"# - set_offset_x ROS service (value = targeted offset in x-axis)\n"
"# - set_offset_y ROS service (value = targeted offset in y-axis)\n"
"# - set_demosaicing_mode ROS Service (value : 0 = Simple, 1 = Basler PGI)\n"
"# - set_light_source_preset ROS service (value : 0 = Off, 1 = Daylight5000K, 2 = Daylight6500K, 3 = Tungsten2800K)\n"
"# - set_balance_white_auto ROS service (value : 0 = Off, 1 = Once, 2 = Continuous)\n"
"# - set_sensor_readout_mode ROS service (value : 0 = Normal, 1 = Fast)\n"
"# - set_trigger_selector ROS service (value : 	0 = Frame start, 1 = Frame burst start (ace USB cameras) / Acquisition Start (ace GigE cameras))\n"
"# - set_trigger_source ROS service (value : 0 = Software, 1 = Line1, 2 = Line3, 3 = Line4, 4 = Action1 (only selected GigE Camera))\n"
"# - set_trigger_activation ROS service (value : 0 = RigingEdge, 1 = FallingEdge)\n"
"# - set_line_selector ROS service (value : 0 = Line1, 1 = Line2, 2 = Line3, 3 = Line4)\n"
"# - set_line_mode ROS service (value : 0 = Input, 1 = Output)\n"
"# - set_line_source ROS sevice (value : 0 = Exposure Active, 1 = FrameTriggerWait, 2 = UserOutput1, 3 = Timer1Active, 4 = FlashWindow)\n"
"# - set_device_link_throughput_limit ROS service (value = new targeted throughput limit in Bytes/sec.).\n"
"# - select_user_set ROS service (value : 0 = Default, 1 = UserSet1, 2 = UserSet2, 3 = UserSet3, 4 = HighGain, 5 = AutoFunctions, 6 = ColorRaw)\n"
"# - select_default_user_set ROS service (value : 0 = Default, 1 = UserSet1, 2 = UserSet2, 3 = UserSet3, 4 = HighGain, 5 = AutoFunctions, 6 = ColorRaw)\n"
"# - set_gamma_selector (value: 0 = User, 1 = sRGB)\n"
"\n"
"int32 value 		# value to be setted\n"
;
  }

  static const char* value(const ::camera_control_msgs::SetIntegerValueRequest_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::camera_control_msgs::SetIntegerValueRequest_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.value);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct SetIntegerValueRequest_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::camera_control_msgs::SetIntegerValueRequest_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::camera_control_msgs::SetIntegerValueRequest_<ContainerAllocator>& v)
  {
    s << indent << "value: ";
    Printer<int32_t>::stream(s, indent + "  ", v.value);
  }
};

} // namespace message_operations
} // namespace ros

#endif // CAMERA_CONTROL_MSGS_MESSAGE_SETINTEGERVALUEREQUEST_H
